// Export utilities for various formats

interface ExportOptions {
  projectName: string
  projectDescription?: string
  files: File[]
  fileTree: string
  tokenCount: number
  timestamp?: Date
}

// Copy to clipboard
export async function copyToClipboard(text: string): Promise<boolean> {
  try {
    await navigator.clipboard.writeText(text)
    return true
  } catch (error) {
    console.error('Failed to copy to clipboard:', error)
    // Fallback method
    const textArea = document.createElement('textarea')
    textArea.value = text
    textArea.style.position = 'fixed'
    textArea.style.opacity = '0'
    document.body.appendChild(textArea)
    textArea.select()
    
    try {
      document.execCommand('copy')
      document.body.removeChild(textArea)
      return true
    } catch (err) {
      document.body.removeChild(textArea)
      return false
    }
  }
}

// Generate markdown content
export function generateMarkdownContent(options: ExportOptions): string {
  const date = options.timestamp || new Date()
  const dateStr = date.toISOString().split('T')[0]
  const totalSize = options.files.reduce((acc, file) => acc + file.size, 0)
  
  let content = `# ${options.projectName}\n\n`
  
  if (options.projectDescription) {
    content += `## Description\n${options.projectDescription}\n\n`
  }
  
  content += `## Project Information\n`
  content += `- **Generated Date**: ${dateStr}\n`
  content += `- **Total Files**: ${options.files.length}\n`
  content += `- **Total Size**: ${formatFileSize(totalSize)}\n`
  content += `- **Estimated Tokens**: ${options.tokenCount.toLocaleString()}\n\n`
  
  content += `## File Structure\n`
  content += '```\n'
  content += options.fileTree || 'No file tree generated\n'
  content += '```\n\n'
  
  // Add file list with sizes
  if (options.files.length > 0) {
    content += `## File List\n\n`
    content += `| File Name | Size |\n`
    content += `|-----------|------|\n`
    
    const sortedFiles = [...options.files].sort((a, b) => a.name.localeCompare(b.name))
    sortedFiles.forEach(file => {
      const path = file.webkitRelativePath || file.name
      content += `| ${path} | ${formatFileSize(file.size)} |\n`
    })
    content += '\n'
  }
  
  content += `---\n`
  content += `*Generated by [ContextViber](https://contextviber.com) on ${new Date().toLocaleString()}*\n`
  
  return content
}

// Generate JSON export
export function generateJSONExport(options: ExportOptions): string {
  const exportData = {
    project: {
      name: options.projectName,
      description: options.projectDescription,
      exportDate: new Date().toISOString(),
      statistics: {
        totalFiles: options.files.length,
        totalSize: options.files.reduce((acc, file) => acc + file.size, 0),
        estimatedTokens: options.tokenCount
      }
    },
    fileTree: options.fileTree,
    files: options.files.map(file => ({
      name: file.name,
      path: file.webkitRelativePath || file.name,
      size: file.size,
      type: file.type || 'unknown',
      lastModified: new Date(file.lastModified).toISOString()
    }))
  }
  
  return JSON.stringify(exportData, null, 2)
}

// Download as file
export function downloadFile(content: string, filename: string, mimeType: string = 'text/plain') {
  const blob = new Blob([content], { type: mimeType })
  const url = URL.createObjectURL(blob)
  const link = document.createElement('a')
  link.href = url
  link.download = filename
  document.body.appendChild(link)
  link.click()
  document.body.removeChild(link)
  URL.revokeObjectURL(url)
}

// Export as Markdown file
export function exportAsMarkdown(options: ExportOptions) {
  const content = generateMarkdownContent(options)
  const filename = `${options.projectName.replace(/\s+/g, '_')}_context.md`
  downloadFile(content, filename, 'text/markdown')
}

// Export as JSON file
export function exportAsJSON(options: ExportOptions) {
  const content = generateJSONExport(options)
  const filename = `${options.projectName.replace(/\s+/g, '_')}_export.json`
  downloadFile(content, filename, 'application/json')
}

// Export as Text file
export function exportAsText(options: ExportOptions) {
  let content = `${options.projectName}\n${'='.repeat(options.projectName.length)}\n\n`
  
  if (options.projectDescription) {
    content += `Description: ${options.projectDescription}\n\n`
  }
  
  content += `Files: ${options.files.length}\n`
  content += `Total Size: ${formatFileSize(options.files.reduce((acc, f) => acc + f.size, 0))}\n`
  content += `Tokens: ${options.tokenCount.toLocaleString()}\n\n`
  
  content += `File Structure:\n${options.fileTree || 'Not generated'}\n`
  
  const filename = `${options.projectName.replace(/\s+/g, '_')}_context.txt`
  downloadFile(content, filename, 'text/plain')
}

// Generate shareable link (for future implementation)
export function generateShareableLink(options: ExportOptions): string {
  // This would integrate with a backend service
  // For now, return a placeholder
  const baseUrl = 'https://contextviber.com/share/'
  const shareId = btoa(options.projectName + Date.now()).slice(0, 8)
  return `${baseUrl}${shareId}`
}

// Format file size helper
function formatFileSize(bytes: number): string {
  if (bytes === 0) return '0 B'
  const units = ['B', 'KB', 'MB', 'GB']
  const k = 1024
  const i = Math.floor(Math.log(bytes) / Math.log(k))
  return `${(bytes / Math.pow(k, i)).toFixed(2)} ${units[i]}`
}

// Generate context for AI (optimized format)
export function generateAIContext(options: ExportOptions): string {
  let context = `PROJECT: ${options.projectName}\n`
  
  if (options.projectDescription) {
    context += `DESCRIPTION: ${options.projectDescription}\n`
  }
  
  context += `\nSTATISTICS:\n`
  context += `- Files: ${options.files.length}\n`
  context += `- Size: ${formatFileSize(options.files.reduce((acc, f) => acc + f.size, 0))}\n`
  context += `- Tokens: ~${options.tokenCount.toLocaleString()}\n`
  
  context += `\nSTRUCTURE:\n${options.fileTree || 'Not available'}\n`
  
  // Add key file types
  const fileTypes = new Map<string, number>()
  options.files.forEach(file => {
    const ext = file.name.split('.').pop() || 'no-ext'
    fileTypes.set(ext, (fileTypes.get(ext) || 0) + 1)
  })
  
  context += `\nFILE TYPES:\n`
  Array.from(fileTypes.entries())
    .sort((a, b) => b[1] - a[1])
    .forEach(([ext, count]) => {
      context += `- .${ext}: ${count} files\n`
    })
  
  return context
}